/**
 * Mastery Drill: No.27 (try-catch / クラッシュ回避)
 * --------------------------------------------------
 * 【シナリオ】
 * 外部から届いたデータが「壊れている」ことを想定し、
 * プログラム全体が停止（クラッシュ）するのを未然に防げ。
 * --------------------------------------------------
 */

var dangerousData = "I am not JSON"; // 不正なデータ

try {
    // --- [挑戦する処理] ---
    // ここでエラーが発生すると、即座に catch ブロックへ飛ぶ
    var result = JSON.parse(dangerousData);
    console.log("パース成功:", result);

} catch (e) {
    // --- [失敗時のリカバリ] ---
    // e.message には「なぜ失敗したか」の理由が入っている
    console.error("Q27 [Error]: パースに失敗しました。処理を継続します。");
    console.error("理由: " + e.message);

    // リカバリ処理（デフォルト値を設定するなど）
    var result = {}; 
} finally {
    // --- [成否に関わらず実行] ---
    // ログの締めくくりや、リソースの解放などに使う
    console.log("Q27: 通信処理を終了しました。");
}

/**
 * 【ハックのポイント：精読時の眼力】
 * 1. 握りつぶし（サイレント・エラー）:
 * catch (e) { } のように、中身が空のコードを見つけたら要注意。
 * エラーが起きているのに誰も気づけない「最も気まずいバグ」の温床です。
 * * 2. 適用範囲の広すぎ:
 * スクリプト全体を1つの try-catch で囲むのは「プロの怠慢」。
 * 「どこでエラーが起きたか」を特定しやすくするため、
 * JSON.parse や API通信など、失敗しそうな箇所にピンポイントでかけるのが正解です。
 */