### 📂 Q34 (Deep Dive): データ浄化のゴールデンフロー

実務でよくある「CSV形式の設定値」を処理する最強のパターンです。

```javascript
/**
 * Mastery Drill: No.34 (Advanced / Data Sanitization)
 * --------------------------------------------------
 * 【シナリオ】
 * システムプロパティから取得した「利用を許可するロール一覧」を処理せよ。
 * 設定値: " admin, itil , knowledge " (前後にバラバラな空白がある)
 * --------------------------------------------------
 */

var rawSetting = " admin, itil ,  knowledge "; // 外部からの「汚れた」入力

// 1. split(',') で配列化
var rawArray = rawSetting.split(","); 

// 2. 浄化されたデータを格納する配列
var cleanArray = [];

// 3. ループ (Q24) で回しながら、1つずつ掃除 (Q28)
for (var i = 0; i < rawArray.length; i++) {
    var item = rawArray[i].trim(); // ここで空白を除去！
    
    // ガード句 (Q11/Q31) : 空要素（カンマが連続していた場合など）を弾く
    if (item !== "") {
        cleanArray.push(item);
    }
}

console.log("浄化後:", cleanArray); // ["admin", "itil", "knowledge"]

/**
 * 【精読時の致命的なチェックポイント】
 * 1. trim() が無い場合のリスク:
 * if (role === "admin") という比較をする際、" admin"（空白あり）だと
 * 判定が false になり、権限エラーが発生します。これが「設定は合ってるのに動かない」の正体です。
 * 2. カンマの後の空白:
 * 人間が読みやすいように "A, B, C" と書くと、JS側では ["A", " B", " C"] になります。
 * この「2番目以降の空白」を処理しているかどうかが、スクリプトの品質の分かれ目です。
 */

```

---

### 💡 さらに踏み込んだ「勝ち筋」：正規表現による一括解決

「気まずいスクリプト」をスマートに書き換える（あるいは読む）際、プロは `split` に正規表現を渡して、一気に `trim` 相当の処理を済ませることがあります。

```javascript
// カンマの前後の空白を「含めて」区切り文字とする正規表現: /\s*,\s*/
// \s* = 0文字以上の空白
var smartArray = rawSetting.trim().split(/\s*,\s*/);

```

これ一撃で、個別の `trim()` ループが不要になる場合があります。精読中に `/.../` で囲まれた `split` を見つけたら、「あ、こいつは空白の混入まで予見して書いているな」と、そのコードの作者のレベルが高いことを察知できます。

---
