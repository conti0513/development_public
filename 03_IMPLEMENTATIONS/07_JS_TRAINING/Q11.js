/**
 * Mastery Drill: No.11 (Functions & Guard Clauses)
 * --------------------------------------------------
 * 【お題】2つの引数 a, b を足し算して返す関数 add を作成せよ
 * --------------------------------------------------
 */

// --- [ES5: Standard Style + Guard Clause] ---
function add_legacy(a, b) {
    // 【ガード句】GOの if err != nil 的な発想
    // JSは型がないので、実行前に自前でチェックするのが「プロの防衛策」
    if (typeof a !== 'number' || typeof b !== 'number') {
        console.warn('Warning: 引数に数値以外が渡されました。');
        return 0; // またはエラーを投げる
    }
    return a + b;
}

console.log('ES5 (Safe): ' + add_legacy(10, 20)); // 30
console.log('ES5 (Invalid): ' + add_legacy('10', 20)); // ガード句で 0 が返る


// --- [ES6: Arrow Function Style] ---
// 短く書けるが、ガード句を入れる場合はブロック { } が必要になる。
const add_modern = (a, b) => {
    return a + b; 
};

/* ▼ 関数と引数の言語別比較表
  -----------------------------------------------------------------------
  | 特徴         | JS (ES5/6)      | PHP             | GO (Golang)      |
  | :----------- | :-------------- | :-------------- | :--------------- |
  | 引数の型定義 | できない         | 任意            | **必須** |
  | 不足した引数 | `undefined` になる | 警告/エラー      | **コンパイルエラー** |
  | 余分な引数   | 無視して動く     | 無視して動く    | **コンパイルエラー** |
  -----------------------------------------------------------------------
*/

/**
 * 【解法ポイント】
 * 1. JSの関数は「引数の数」も「型」もチェックしない。
 * add(10) と呼ぶと b は `undefined` になり、結果は `NaN` (Not a Number) になる。
 * 2. GOならコンパイラが守ってくれるが、JSでは自前で `typeof` を使ったガード句を書く必要がある。
 * 3. 現場でのマインドセット: 「引数は常に汚染されている（型が違うかもしれない）」と疑い、
 * 特に関数冒頭で不正な値を弾く（早期リターンする）のが、バグを未然に防ぐコツ。
 */