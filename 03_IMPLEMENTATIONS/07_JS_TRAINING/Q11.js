/**
 * Mastery Drill: No.11 (Functions & Guard Clauses)
 * --------------------------------------------------
 * 【お題】
 * 1. 2つの引数 a, b を足し算して返す関数 add を作成せよ。
 * 2. 引数が数値でない場合、即座に処理を中断する「ガード句」を実装せよ。
 * 3. 正常系をネスト（深掘り）させない「早期リターン」の形を整えよ。
 * --------------------------------------------------
 */

// --- [ES5: Professional Guard Style] ---
function add_safe(a, b) {
    
    // 1. 【ガード句：存在チェック】引数が足りない場合を弾く
    if (typeof a === 'undefined' || typeof b === 'undefined') {
        console.warn('Q11 Warning: 引数が不足しています。');
        return 0; 
    }

    // 2. 【ガード句：型チェック】"10" + 20 = "1020" になる事故を防ぐ
    // JSの型は嘘をつくので、実行直前に typeof で門前払いする
    if (typeof a !== 'number' || typeof b !== 'number') {
        console.warn('Q11 Warning: 数値以外が渡されました。');
        return 0; 
    }

    // 3. 【正常系】ガード句を抜けた後は、100%安全なデータだけが残る
    // ここが左端（ネストなし）にあることが、読みやすさの証
    return a + b;
}

// 実行テスト
console.log('Q11 正常系: ' + add_safe(10, 20));   // 30
console.log('Q11 異常系: ' + add_safe('10', 20)); // 0 (警告が出る)


/**
 * 【現場の深掘りポイント】
 * * 1. 「早期リターン」のメリット:
 * else 文をダラダラ書くのをやめ、異常なケースを「先に追い出す」ことで、
 * 関数の本質的なロジック（正常系）が右に深くならず、読みやすくなります。
 * * 2. ServiceNow等のレガシー環境での罠:
 * 古いエンジンでは ES6 のデフォルト引数 (a = 0) が使えないことがあります。
 * その場合、Q33で学んだ `a = a || 0;` という短絡評価を関数冒頭で使うのが
 * 「気まずいスクリプト」を安全にするコツです。
 * * 3. 関数は「スコープの境界線」:
 * この中で定義した変数は、外側を汚しません。
 * この「隔離」こそが、大規模開発でバグを広げないための唯一の壁です。
 * 1行ハック：「異常系を『先に』追い出し、正常系を『インデントなし』で書くのが、読みやすさと安全を両立する鉄則」
 */