/**
 * Mastery Drill: No.14 (Array Mutations)
 * --------------------------------------------------
 * 【お題】配列 list に 'Orange' を追加し、その挙動をメモリ管理の視点で理解せよ。
 * --------------------------------------------------
 */

// --- [実務の基本形] ---
var list = ['Apple', 'Banana'];

// 1. 破壊的操作 (Mutating): 元の配列そのものを書き換える
list.push('Orange', 'Mango'); 

console.log('Modified List: ' + list.join(', ')); // Apple, Banana, Orange


/* ▼ 【プロの視点】破壊的操作の「罠」と「メモリ」
  -----------------------------------------------------------------------
  | 操作の種類   | メソッド        | メモリ上の挙動                      | リスク |
  | :----------- | :-------------- | :---------------------------------- | :----- |
  | **破壊的** | push, pop, shift| 同じメモリ番地の中身を直接書き換える | 副作用大 |
  | **非破壊的** | concat, slice   | 元の配列は残し、別の場所にコピーを作る | 安全・高負荷 |
  -----------------------------------------------------------------------
*/

/**
 * 【ハックのポイント：なぜ「破壊」を意識するのか？】
 * * 1. 副作用 (Side Effects):
 * ServiceNowや巨大なSaaSのコードでは、一つの配列を複数の関数で参照していることがあります。
 * ある関数で `push` した結果、無関係な場所のデータまで変わってしまうバグは「レガシーあるある」です。
 * * 2. モダンな現場での流儀:
 * 最新のJS環境やReact等では「Immutability（不変性）」が重視されます。
 * その場合は push を使わず、以下のように「スプレッド演算子」で新しい配列を作ります。
 * const newList = [...list, 'Orange']; // 元の list は壊さない
 * * 3. リハビリ・マントラ:
 * 「今、俺が叩いているこのメソッドは、元のデータを壊しているか？」
 * この自問自答ができるだけで、シニアエンジニアとしての格が変わります。
 * 1行ハック：「『とりあえず push』は卒業。その操作が他の場所のデータまで変えてしまわないか、常に『副作用』の範囲を疑え」
 */