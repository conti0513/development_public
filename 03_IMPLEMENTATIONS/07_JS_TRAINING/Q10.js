/**
 * Mastery Drill: No.10 (Loops & Scope)
 * --------------------------------------------------
 * 【お題】1 から 5 までを順に出力する
 * --------------------------------------------------
 */

// --- [ES5: 伝統的なスタイル] ---
// 初期値1 / 5以下まで / 1ずつ増やす
for (var i = 1; i <= 5; i++) {
    console.log('ES5 Count: ' + i);
}

/* ⚠️ JS(var)の罠: ループの外でも変数が生きている */
console.log('ES5 Loop finished. i is now: ' + i); // 結果は "6"


// --- [ES6: モダンなスタイル] ---
// let を使うことで、GOと同じ「厳格なスコープ」になります。
for (let j = 1; j <= 5; j++) {
    // console.log(`ES6 Count: ${j}`);
}
// console.log(j); // ここで呼ぶとエラーになる（GOと同じ挙動で安全！）


/* ▼ ループ・インクリメント比較表
  -----------------------------------------------------------------------
  | 項目         | JS (ES5/6)     | PHP            | GO (Golang)      |
  | :----------- | :------------- | :------------- | :--------------- |
  | 基本構文     | for (i=1;...)  | for ($i=1;...) | for i := 1; ...  |
  | 終了条件     | i <= 5         | $i <= 5        | i <= 5           |
  | 増分演算子   | i++ / ++i      | $i++           | **i++ のみ** |
  | 外での生存   | **varなら生きる**| 生きる         | **死ぬ (安全)** |
  -----------------------------------------------------------------------
*/

/**
 * 【解法ポイント】
 * 1. 動作認識（1から開始、5以下で継続、毎度+1）は完璧です。
 * 2. GO経験者として注意すべきは、JSの `var` はループが終わってもカウンタ変数が消えない点。
 * 3. 実務（ServiceNow等）では、同じ関数内で別のループを書くときに `i` が衝突しないよう注意が必要です。
 */