# Modern JS Migration Guide (From ES5 to ES6+)

## 概要

本プロジェクトは、エンタープライズ領域（ERP、ワークフローシステム、レガシーなSaaS実行基盤など）で依然として主流である **ECMAScript 5 (ES5 / Rhinoエンジン等)** のコードベースを、最新の **ES6+ (Node.js/GAS V8等)** へ安全に移行・保守するためのリファレンスガイドです。

「モダンな構文をただ使う」のではなく、**「実行環境の制約を理解した上で、いかに壊さず、保守性の高いコードを書くか」** に焦点を当てています。

---

## ⚡ Quick Reference: ES5 vs Modern JS

ServiceNowなどのエンタープライズ環境で遭遇する「レガシーの制約」と、最新の書き方の対比です。

| カテゴリ | Legacy (ES5 / Rhino) | Modern (ES6+ / V8) | 移行時の注意点 |
| --- | --- | --- | --- |
| **変数宣言** | `var` | `const` / `let` | ES5ではブロックスコープが効かないため `var` を使用。 |
| **関数** | `function name() {}` | `const name = () => {}` | アロー関数はES5環境では構文エラー。 |
| **文字列** | `'A' + b + 'C'` | ``A${b}C`` | テンプレートリテラルが使えない環境では `+` 結合が必須。 |
| **非同期** | Synchronous (Callback) | `async` / `await` | ES5（Rhino）は同期実行。Promiseは未実装の場合が多い。 |
| **配列操作** | `for (var i=0; ...)` | `forEach`, `map`, `filter` | 高階関数は古いエンジンで未サポートの場合がある。 |

---

## 🎓 40-Step Mastery Drill (一問一答ノック)

レガシー環境での開発・保守において、「さら」で書けるべき必須パターン集です。

## 📂 1. Basic Foundations (基礎編)

| No | テーマ | 解法ポイント & 罠 | 関連ファイル |
| :--- | :--- | :--- | :--- |
| 01 | **変数代入** | ES5の `var` と ES6の `const/let` のスコープの違い。 | `Q01.js` |
| 02 | **文字列定義** | バッククォート (`` ` ``) によるテンプレートリテラルの利便性。 | `Q02.js` |
| 03 | **算術演算** | 文字列結合時の「1020問題」を () や ${} で防衛する。 | `Q03.js` |
| 04 | **配列初期化** | ES5における配列の基本操作とES6のスプレッド演算子。 | `Q04.js` |
| 05 | **要素アクセス** | 添字アクセスと、PHPの `list()` に相当する「分割代入」。 | `Q05.js` |
| 06 | **条件分岐** | **【要注意】** JSでは `"0"` や `[]` が **true** になる罠。 | `Q06.js` |
| 07 | **厳密判定** | GOの精神を採用し、常に `===` で型までチェックする。 | `Q07.js` |
| 08 | **コメント** | JSDoc (`/** ... */`) を活用したプロフェッショナルな記述。 | `Q08.js` |
| 09 | **論理演算** | 短絡評価 (`||`) を用いたデフォルト値代入のハック。 | `Q09.js` |
| 10 | **基本ループ** | `var` の生存範囲問題と、カウンタ変数の終了値挙動。 | `Q10.js` |
---

## 📂 2. Intermediate Operations (初級・実務編)

| No | テーマ | 解法ポイント & 罠 | 関連ファイル |
| --- | --- | --- | --- |
| 11 | **関数宣言と引数** | GOの `func` vs JS。型のない引数を守る「ガード句」の概念。 | `Q11.js` |
| 12 | **オブジェクト定義** | JSの心臓。PHPの連想配列やGOのStructとの構造的違い。 | `Q12.js` |
| 13 | **プロパティ参照** | `obj.key` と `obj['key']` の使い分け（ServiceNow実務必須）。 | `Q13.js` |
| 14 | **配列の破壊的操作** | `push` / `pop` による配列操作とメモリ管理の意識。 | `Q14.js` |
| 15 | **配列長と空判定** | `length` を使用した、型に依存しない安全なループ制御。 | `Q15.js` |
| 16 | **戻り値と早期リターン** | GOの `if err != nil` に倣った、ネストを浅くする書き方。 | `Q16.js` |
| 17 | **型変換の儀式** | `parseInt` の罠。第2引数（基数）を省略してはいけない理由。 | `Q17.js` |
| 18 | **剰余算と偶奇判定** | `%` 演算子を用いたアルゴリズムの基礎と実務転用。 | `Q18.js` |
| 19 | **論理演算の優先順位** | `&&` と ` |  |
| 20 | **三項演算子** | `condition ? a : b`。簡潔さと可読性のトレードオフ。 | `Q20.js` |

---


### 3. Advanced Scripting (中級・データ処理)

21. **JSONパース**: `JSON.parse(str);`
22. **JSON直列化**: `JSON.stringify(obj);`
23. **文字列検索**: `str.indexOf('abc') !== -1`
24. **配列反復**: `for (var i = 0; i < arr.length; i++) { ... }`
25. **型変換(文)**: `String(123);`
26. **日付生成**: `var now = new Date();`
27. **例外処理**: `try { ... } catch (e) { ... }`
28. **トリミング**: `str.trim();`
29. **置換**: `str.replace('A', 'B');`
30. **要素削除**: `arr.splice(i, 1);`

### 4. Enterprise Standard (上級・保守)

31. **Nullチェック**: `if (val === null \|\| val === undefined)`
32. **未定義判定**: `if (typeof val === 'undefined')`
33. **デフォルト値**: `val = val \|\| 'default';`
34. **分割**: `str.split(',');`
35. **継続判定**: `while (condition) { ... }`
36. **数値判定**: `isNaN(num)`
37. **結合(配列)**: `arr.join(', ');`
38. **三項演算子**: `var res = ok ? 'Y' : 'N';`
39. **メンバ列挙**: `for (var key in obj) { ... }`
40. **即時実行関数**: `(function(){ ... })();`

---

## 🛠️ Best Practices in Enterprise Environment

1. **Avoid `const/let**`: ES5環境へのデプロイが想定される場合、ランタイムエラーを避けるため `var` を使用する。
2. **Explicit Type Conversion**: `parseInt` では常に基数（10進数なら10）を指定する。
3. **No Event Loop**: サーバーサイド実行環境（Rhino等）では `setTimeout` 等の非同期APIが利用不可であることに留意する。

---
