/**
 * Mastery Drill: No.23 (indexOf / 文字列の存在確認)
 * --------------------------------------------------
 * 【シナリオ：ログ監視やフィルタリング】
 * ログの中に "Error" や "Target" が含まれているか判定せよ。
 * JS特有の「0をFalseとみなす曖昧さ」をプログラムで補正するのがこの問題の核心。
 * --------------------------------------------------
 */

var msg = "Target Found";
var searchKey = "Target";

// --- [論点：JSの仕様とエンジニアの意図のズレ] ---
// indexOf は「見つからなければ -1」「見つかればその座標（0以上）」を返す。
// JSのif構文は「0をfalse」と判定するため、座標0（先頭）で見つかった「成功」を
// 「失敗（見つからなかった）」と誤解してバグを生む。

// 修正後：存在の有無という「判断基準」を明確にするために !== -1 を使う。
if (msg.indexOf(searchKey) !== -1) {
    console.log("Q23: [" + searchKey + "] が先頭(0)または途中で見つかりました。");
} else {
    // 本当に -1（どこにも存在しない）の時だけここを通る
    console.log("Q23: 見つかりませんでした。");
}

/**
 * 【ハックのポイント：精読時の眼力】
 * 1. 「0」はデータであり、判定ではない:
 * Go言語では数値(int)と真偽値(bool)が厳格に区別されるため、数値(0)をifに入れるとエラーになる。
 * しかし、JSは数値を勝手に真偽値へ型変換（0 -> false）してしまう。
 * 精読会で if (msg.indexOf("xxx")) というコードを見つけたら
 * 「先頭にある時にfalse扱いされるバグ」として即座にツッコミを入れよ。
 * * 2. 座標を意識したコードリーディング:
 * [T][a][r][g][e][t]
 * 0  1  2  3  4  5
 * indexOf("Target") は 0 を返す。JSにとって 0 は「虚無(Falsy)」だが、
 * 運用上は「最重要（先頭一致）」である。この認識のズレを埋めるのが !== -1 である。
 * ポイント：JSでは0はFalse /「検索結果の 0（先頭）を false と勘違いするな。判定は必ず !== -1 で行え」
 */