# Tips
※ターミナルを右側に表示
> terminal
> 右クリック
> Move Panel Right

# asciiflow
https://asciiflow.com/

#【第1回】Dockerインストール→Linux(CentOS7)を起動
https://harusite.net/20230207-docker/

#【第2回】Linuxの概要／GCPでUbuntuをインストール
https://harusite.net/20230217-docker/

#【第3回】WEBサーバを構築（Nginx）／ネットワークの概要
https://harusite.net/20230218-docker/

#【第4回】WEBアプリ構築／Dockerでの環境構築準備
https://harusite.net/20230221-docker/

#【第5回】Dockerの概要
https://harusite.net/20230225-docker/

#【第6回】ハンズオン／Dockerのインストール・作成・起動・停止
https://harusite.net/20230303-docker/




# PHPの環境構築

### Dockerを使用
参考URL
https://youtube.com/watch?v=JP2f1R432Fw&feature=shares
https://idealump.com/service/lab/95

ほぼ上手くいった
ブラウザに表示されない
https://webukatu.com/wordpress/blog/13099/




目次
Dockerによる環境構築
1.  Dockerのインストール
2.  ディレクトリ・ファイルの準備
3.  Dockerfileの作成
4.  docker-compose.ymlの作成
5.  index.phpの作成
6.  コンテナの起動
7.  動作確認

#### 環境情報
PC
・MacBookAir M1

Docker Desctop
・Ver

開発環境
・Apache
・PHP 

#### Dockerの構築フロー
 Dockerfile
 　自分で作る
 　Imageを自作するためのファイル

  ↓　build
 　 
 image
 　コンテナを起動する土台
 　DockerHubで公開されている

  ↓　run

 Container(コンテナ）
 　アプリケーションの実行環境
 　使い捨て可能
 　開始・停止・削除
---

#### Apacheとドキュメントルート
Apache
 Webサーバのソフトウェア
 Webブラウザのリクエストに応じて、ファイルをレスポンスで返す

ドキュメントルート
　外部に公開されたファイルが置かれたディレクトリ
　ドキュメントルートがアクセスの起点になる


#### 手順
Dockerアプリのインストール　別な手順で対応済み
表示するphpファイルなどのフォルダ作成
Dockerfilewo作成
Dockerfilekaraイメージを作成
コンテナ作成・起動

※Dockerfieleに書いておかないと、意図したファイルがひらけない

P1
FROM php:8.1.12-apache
COPY src; /var/www/html

 P2
 公式ドキュメントに
 ドキュメントルート
 　ポート
 が書いてあるのでその通りにやること

 Docker ーーー> PHP serach

 ---

一旦Dockerをストップする
docker-compose down




## 1.  Dockerのインストール
以前対応した手順

## 2.  ディレクトリ・ファイルの準備
今回の環境構築用に、ローカルPCの任意の場所にdocker-phpフォルダを作成

構成
---
docker-php
    ├── docker-compose.yml //ファイル
    ├── html               //フォルダ 一旦やめ
    ├──src                 //フォルダ
        └── index.php      //ファイル
    ├── mysql              //フォルダ
    └── php                //フォルダ
    ├── Dockerfile         //ファイル
    └── php.ini            //ファイル

※上記の通り、Documentrootにindex.phpを配置すること
※また、配置場所とdocker-compose.ymlの記載内容を合わせること

## 3.  Dockerfileの作成
---
FROM php:8.1.12-apache

RUN apt-get update && apt-get install -y libonig-dev && \

docker-php-ext-install pdo_mysql mysqli mbstring
---

前の記載
FROM php:8.1.12-apache
COPY src; /var/www/html
RUN apt-get update && apt-get install -y libonig-dev && \
docker-php-ext-install pdo_mysql mysqli mbstring
---


P Dockerfileとは？
Dockerイメージをビルドするためのテキストファイル
Dockerfile内に記述された手順に従って、Dockerイメージを自動的に作成することができる

p Dockerfileの構文
---
INSTRUCTION arguments
---

Dockerfileでは、Dockerイメージを構築するために必要な手順を指定することが可能
例えば、以下のような手順がある

FROM:       ベースとなるイメージを指定します。
RUN:        コマンドを実行します。
COPY:       ファイルやディレクトリをコピーします。
ADD:        ファイルやディレクトリを追加します。
EXPOSE:     コンテナが使用するポートを指定します。
CMD:        コンテナが起動したときに実行するコマンドを指定します。
ENTRYPOINT: コンテナが起動したときに実行するコマンドを指定します。

Dockerfileは、Dockerコマンドを使用してビルドされ、Dockerイメージが作成される
以下のコマンドでは、Dockerfileが存在するディレクトリへのパスと、イメージの名前を指定している
Dockerは、Dockerfileを解析し、イメージを自動的にビルドする


# 実行例
$ docker build -t <image_name> <path_to_Dockerfile>
---


## 4.  docker-compose.ymlの作成
---
version: '3'
services:

  #MySQL用コンテナ
  mysql:
    container_name: mysql
    image: mysql:5.7
    # for m1 mac
    platform: linux/x86_64

    # 要確認
    volumes:
      - ./mysql:/var/lib/mysq
    ports:
      - 3306:3306
    environment:
      - MYSQL_ROOT_PASSWORD=root
      - MYSQL_DATABASE=test
      - MYSQL_USER=test
      - MYSQL_PASSWORD=test
    build:
      context: ./
      dockerfile: Dockerfile
  #phpMyAdmin用コンテナ
  phpmyadmin:
    container_name: phpMyAdmin
    depends_on:
      - mysql
    image: phpmyadmin/phpmyadmin
    environment:
      PMA_HOST: mysql
    restart: always
    ports:
      - "0:80"
    build:
      context: ./
      dockerfile: Dockerfile
  #php用コンテナ
  php:
    container_name: php-apache
    build: ./php

    # 要確認
    volumes:
      - ./html:/var/www/html

    ports:
    # - 0:8080
      - "0:8080"
    depends_on:
      - mysql
    build:
      context: ./
      dockerfile: Dockerfile
---


P docker-compose.yml に以下を入れないとこける

# for m1 mac
platform: linux/x86_64

# ホスト側のポートは0にして自動でポートを割り当てる
# [ホスト側のポート番号]:[コンテナ側のポート番号]
services:
  app:
    image: example/app
    ports:
      - "0:80"
---

確認方法
docker-compose ps

---

 # volumes:    
 # <- Bind mount するディレクトリ。volume。docker run コマンドの-v/--volume に相当
 #  - "$PWD/app-server/src:/usr/src/app"
 # 参考URL https://qiita.com/mk-tool/items/1c7e4929055bb3b7aeda
# COPY ./hogehoge /tmp


## 5.  index.phpの作成
---
<?php
    print("Hello, World");
---

## 6.  コンテナの起動
$ cd docker-php
$ docker-compose up -d

# result
# 数分待った後、以下のメッセージが出れば、ビルド完了
:
:
Creating mysql ... done
Creating php-apache ... done
Creating phpMyAdmin ... done
---

# イメージの確認
$ docker images
REPOSITORY              TAG       IMAGE ID       CREATED              SIZE
docker-php_php          latest    2de314dfa2bc   About a minute ago   450MB
phpmyadmin/phpmyadmin   latest    2de314dfa2bc   About a minute ago   450MB
mysql                   5.7       a118b189427a   2 minutes ago        480MB
nginx                   latest    114aa6a9f203   2 days ago           135MB

$ docker ps



## 7.  動作確認

# 起動したdockerのポート番号を確認
$ docker ps
CONTAINER ID   IMAGE                   COMMAND                  CREATED         STATUS         PORTS                             NAMES
7290240e5f0b   docker-php_php          "docker-php-entrypoi…"   2 minutes ago   Up 2 minutes   80/tcp, 0.0.0.0:32769->8080/tcp   php-apache
3f88839ba2d4   phpmyadmin/phpmyadmin   "docker-php-entrypoi…"   2 minutes ago   Up 2 minutes   0.0.0.0:32768->80/tcp             phpMyAdmin
a003deb936ae   mysql:5.7               "docker-php-entrypoi…"   2 minutes ago   Up 2 minutes   80/tcp, 0.0.0.0:3306->3306/tcp    mysql

# php-apache
curl http://localhost:32769/
curl: (52) Empty reply from server




# phpMyAdmin
$ curl http://localhost:32768/



# エラー対応

# 作業中のコンテナにシェルで入る
$ docker exec -it CONTAINER_ID bash

# sample

$ docker ps        
CONTAINER ID   IMAGE                   COMMAND                  CREATED         STATUS         PORTS                             NAMES
0f91d9d3adfc   docker-php_php          "docker-php-entrypoi…"   3 minutes ago   Up 3 minutes   80/tcp, 0.0.0.0:32771->8080/tcp   php-apache

$ docker exec -it 0f91d9d3adfc bash

# php -v
PHP 8.1.12 (cli) (built: Nov 15 2022 02:27:47) (NTS)
Copyright (c) The PHP Group
Zend Engine v4.1.12, Copyright (c) Zend Technologies
---
PHPは起動している


# PHPが正常に起動しているかどうかを確認するために、以下のコマンドを実行
php -r 'echo "Hello, world!";'
正常起動している













# 注意点
コンテナは再利用可能なので、終わったら消す
どっかーデスクトップからでもいいし、コマンドからでもいい







# エラー対応

PHPの環境を構築するもブラウザからうまく見れない
http://localhost:8080 NG
http://localhost It Worksと出る。

curl locaohost
一緒

Local Hostは以下を見ている
/Library/WebServer/Documents/index.html.en

http://localhost/index.html

---


これで切り分け
https://www.udemy.com/course/webphpmysqldocker/learn/lecture/32559446#overview

うまくいかない
docker run -d -p 80:80 --name my-apach-php-app -v ${PWD}:/var/www/html php 7.2-apache
docker run -d -p 8081:80 --name my-apach-php-app -v ${PWD}:/var/www/html php 7.2-apache
docker run -d -p 8081:80 --name my-apach-php-app -v ${PWD}:/var/www/html php 7.3-apache


一旦破棄
docker stop my-apach-php-app
docker rm my-apach-php-app

確認
Zend Engine v4.2.1, Copyright (c) Zend Technologies
    with Zend OPcache v8.2.1, Copyright (c), by Zend Technologies
yoshi@y0513 docker-php % docker ps -a
CONTAINER ID   IMAGE     COMMAND                  CREATED          STATUS                        PORTS     NAMES
0d32c60be736   php       "docker-php-entrypoi…"   47 seconds ago   Exited (127) 46 seconds ago             my-apach-php-app

---



---
avast 止める
 docker-php % sudo lsof -i :80
COMMAND     PID USER   FD   TYPE             DEVICE SIZE/OFF NODE NAME
httpd     70586 root    4u  IPv6 0xe96e2e172423ddb5      0t0  TCP *:http (LISTEN)
httpd     70594 _www    4u  IPv6 0xe96e2e172423ddb5      0t0  TCP *:http (LISTEN)
com.avast 70624 root   70u  IPv4 0xe96e2e20c4e50a0d      0t0  TCP 192.168.10.103:59548->ams10-013.ff.avast.com:http (ESTABLISHED)
httpd     72272 _www    4u  IPv6 0xe96e2e172423ddb5      0t0  TCP *:http (LISTEN)
httpd     72275 _www    4u  IPv6 0xe96e2e172423ddb5      0t0  TCP *:http (LISTEN)
httpd     72276 _www    4u  IPv6 0xe96e2e172423ddb5      0t0  TCP *:http (LISTEN)
---


懸念点
ドッカーのポート
ローカルのポート
ファイルの場所
その辺。。。。






###########################################################
# memo
###########################################################

ちなみに複数のコンテナを起動する場合
$ docker-composeq







# DevOpsにおけるDockerの立ち位置
Level4 EKS GKSなど（クラウドサービス上でKubenetisを稼働する）
Level3 Kubenetis(クバネティス)
Level2 Docker
Level1 Linux
---



# Dockerの学習を進める注意点
・一旦環境作らないとダメだね。。。
・つまみ食いしてもわからない。。。
・時間はかかるがこの形しかない。

---

１　一旦教材の通りにフルスクラッチで作る
２　教材に従っって、Docker部分も進める
３　手順は一旦がちで作る
４　ブログにアップできそうなところを一旦成果物としてあｐっぷ
５　その後、他で作った環境で同様に対応してみる

---



## rubyのインストール

root@690afb3537ae:/# apt update

apt install ruby ruby-bundler

以上でrubyのインストールは完了
一旦EXITする

コンテナの一覧を確認(停止したコンテナも表示)
docker ps -a

指定したコンテナをイメージにすることができる
docker commit <CONTAINER ID>

P 手作業での環境構築
step1 docker run        # ubuntuのイメージをダウンロード　コンテナを起動
step2 apt install ruby  # Rubyをインストール
step3 docker commit     # コンテナをイメージ化
step4 docker run        # Rubyインストール済みのイメージからコンテナを起動
---

上記のデメリットと代替案
docker commitコマンドは基本的に使わない方がベター
上記の手順だと、どのように環境構築したか分からなくなる
そこで使用するのがDockerFile
Dockerfileを使えば、イメージの構築手順をコード化（Infrastracture as Code）できる

## Dockerfileによるイメージの作成

## Dockerfile をもとにイメージをビルド
```
docker build -t my-ruby:dockerfile .
```

## 自作したイメージからコンテナを起動
```
docker run -it my-ruby:dockerfile bash
```



Dockerfile
---
FROM ubuntu:20.04

RUN apt update
RUN apt install -y ruby ruby-bundler
---

## コンテナのライフサイクル
イメージ      # Docker HubなどからDLするか、コンテナから作成することが可能
Dockerfile   # Dockerfileを元にイメージをbuildする
コンテナ      #　docker run　コマンドで開始できる

## 39
# ボリュームによるファイルの共有

## Ruby のコードをマウントして Bash を実行

```
docker run \
  -v $PWD:/opt/myapp \
  -w /opt/myapp \
  -it \
  my-ruby:dockerfile \
  bash
```

## Ruby のコードをマウントして Ruby を実行

```
docker run \
  -v $PWD:/opt/myapp \
  -w /opt/myapp \
  my-ruby:dockerfile \
  ruby hello.rb
```

---


LinuxシェルのSTDINとSTDOUTとは
ターミナルで見えるシェルはフォアグランドプロセス
インプット（STDIN）とアウトプット（STDOUT&STDERR）が見える

バックグラウンドプロセス
インプットもアウトプットも見えない
バックグラウンドと会話するにはTTYをアタッチする必要がある

p TTY
Tele Typwriter

Dockerの中にシェルで入る場合のコマンド例
$ docker exec --interractive --tty



シェル基本コマンド(DIR)
ls # list ディレクトリ情報の表示
cd # change dir ディレクトリの移動
pwd # print working dir 現在のディレクトリを表示
mkdir # make dir ディレクトリの作成
---

シェルの基本コマンド(FILE)
touch  # ファイルの作成
echo >>   # ファイルにつけたし
cat    # concatenate　ファイルのコンテンツを表示
rm     # remove ファイルを削除

シェルの基本コマンド(PROCESS)
ps
&            # process status プロセスの表示
 sleep 10 &  # プロセスをバックグラウンドで起動
fg           # foreground プロセスをフォアグラウンドに戻す

シェルの基本コマンド(COMMAND)
help    # コマンドのヘルプ
which   # コマンドの保存先を表示
man     # manual コマンドのマニュアルを表示

シェルの基本コマンド(SEARCH)
find   # ファイル・ディレクトリを探す
 $ find / -type d -name nginx

grep
 $ grep "Hello" test.txt -n
 $ find / -type d -name nginx | xargs grep -r html
  # ディレクトリ名を検索
  # その中のファイルを文字検索
  














#########################################################################
以下はWEB APPのハンズオン
#########################################################################

# 典型的な３層構造のWEB APPを作る


## ハンズオンの主な手順

1 サーバの準備／HTMLの実装
2 Ruby(Sinatra)のHello World
3 Nginxのリバースプロキシ設定
4 フロントエンド（JS）とバックエンド（Sinatra）の疎通
5 タスク一覧の取得処理を実装
6 タスクの登録処理を実装
7 JavaScriptの改善
8 MySQLのインストールとテーブルの作成
9 SinatraでMySQLとやり取り


##　1 ハンズオン/サーバの準備／HTMLの実装
GCEでインスタンスを作成
　前の手順と一緒

SSHでアクセス

Nginxをインストールし
　前の手順と一緒

ブラウザからアクセス
　外部IPから

### HTMLの実装

既存のファイルを確認
$ ls /var/www/html
index.nginx-debian.html

既存のファイルを消す
sudo rm index.nginx-debian.html

index.htmlを作成
sudo touch index.html

cat index.html

sudo vi index.html

GCEではVSコードなどの手元の環境でコードを書いてアップロードすることも可能
---
GCEの外部IPをクリック
作成したHTMLファイルに応じて画面が表示されたことを確認

---




##　2 ハンズオン/Ruby(Sinatra)のHello World

### Rubyのインストール
install ruby
sudo apt install ruby

check
$ ruby -v
ruby 2.5.1p57 (2018-03-29 revision 63029) [x86_64-linux-gnu]


bundlerのインストール
bundler management rubys library
sudo apt install ruby-bundler

# bundler 
# rubyのライブラリを管理するツール

# ホームディレクトリ直下に作業用のディレクトリを作成
cd /home/yoshimasa


# ディレクトリが作成されたことを確認
mkdir myapp
cd myapp
pwd
/home/<user-name>/myapp


# sinatraを利用可能にする
# まず、「bundle init」で初期化する
bundle init

# 次にGemfileを編集し、ライブラリを書いていく

# Gemfileが存在することを確認
ll
total 12
drwxrwxr-x 2 yoshimasa yoshimasa 4096 Feb 19 22:59 ./
drwxr-xr-x 6 yoshimasa yoshimasa 4096 Feb 19 22:58 ../
-rw-r--r-- 1 yoshimasa yoshimasa  146 Feb 19 22:59 Gemfile
--

vi Gemfile
gem "sinatra", "2.2.0"



oshimasa@instance-1:~/myapp$ vim Gemfile 
yoshimasa@instance-1:~/myapp$ cat Gemfile 
# frozen_string_literal: true

source "https://rubygems.org"

git_source(:github) {|repo_name| "https://github.com/#{repo_name}" }

# gem "rails"
gem "sinatra", "2.2.0"

---

# gem fileに書かれているので、sinatraがインストールされる
bundle install

---
installed sinatra


### Hello World at sninatra
sinatoraでHello Worldを表示するための実装をする
コードはsinatraのHPから取得可能
>> SINATRA
https://sinatrarb.com/


# myapp.rbを編集していく
vi myapp.rb


---
require 'sinatra'
get '/' do
  'Hello, World'
end
---

ruby myapp.rb

# rubyのポートを確認
check ruby on 4576
---
 ruby myapp.rb
[2023-02-19 23:09:23] INFO  WEBrick 1.4.2
[2023-02-19 23:09:23] INFO  ruby 2.5.1 (2018-03-29) [x86_64-linux-gnu]
== Sinatra (v2.2.0) has taken the stage on 4567 for development with backup from WEBrick
[2023-02-19 23:09:23] INFO  WEBrick::HTTPServer#start: pid=3623 port=4567


---
# GREで別なSSH接続Windowを起動する
opne another SSH window at GRE
type following code
curl http://localhost:4567

$ curl http://localhost:4567
Hello, Worldyoshimasa@instance-1:~$

quit by Ctrl + c
--

add another code
open myapp.rb

vi myapp.rb

---
require 'sinatra'
get '/' do
  'Hello, World'
end

get '/api/hello' do
  {
    message: 'Hello World!'
  }.to_json
end
---

curl http://localhost:4567/api/hello


 curl http://localhost:4567/api/hello
{"message":"Hello World!"}yoshimasa@instance-1:~$ 
---

以上で、sinatoraでの疎通確認は完了




## 3 Nginxのリバースプロキシ設定

P リバースプロキシとは
ブラウザからサーバへの通信はnginxが受け取るようになっている
URLのパスが/api/から始まる場合のみ、処理をSinatraに依頼したい
このように本当に処理を依頼サーバの手前に挟まるサーバを「リバースプロキシ」を呼ぶ


### nginxの設定を見ていく
やりたいこと
nginxのパスが/api/であれば、sinatraに転送される設定を入れる

---
# 以下にnginxの設定ファイルが存在する
yoshimasa@instance-1:~/myapp$ cd /etc/nginx
yoshimasa@instance-1:/etc/nginx$ pwd
/etc/nginx

$ cat nginx.conf 
---


# 設定ファイルを編集することで、一部のアクセスを他のプロセスに受け私が可能
sudo vi /etc/nginx/sites-enabled/default

# 「location /」の下に以下を記載していく
location /api/ {
  proxy_pass http://localhost:4567;
}
---
# 記載されたか確認
cat /etc/nginx/sites-enabled/defaul

# nginxをリロード
sudo systemctl reload nginx

---

動作確認

ssh 1 rubyを起動
yoshimasa@instance-1:~$ cd myapp/
yoshimasa@instance-1:~/myapp$ ls
Gemfile  Gemfile.lock  myapp.rb
yoshimasa@instance-1:~/myapp$ 
yoshimasa@instance-1:~/myapp$ 
yoshimasa@instance-1:~/myapp$ ruby myapp.rb


ssh2でnginxにアクセスすると、sinatraに処理が転送されたことがわかる
---
[2023-02-24 21:59:35] INFO  WEBrick 1.4.2
[2023-02-24 21:59:35] INFO  ruby 2.5.1 (2018-03-29) [x86_64-linux-gnu]
== Sinatra (v2.2.0) has taken the stage on 4567 for development with backup from WEBrick
[2023-02-24 21:59:35] INFO  WEBrick::HTTPServer#start: pid=3415 port=4567
127.0.0.1 - - [24/Feb/2023:22:01:00 +0000] "GET /api/hello HTTP/1.1" 200 26 0.0056
127.0.0.1 - - [24/Feb/2023:22:01:00 UTC] "GET /api/hello HTTP/1.0" 200 26
- -> /api/hello
---



ssh 2
curl http://localhost/api/hello

curl http://localhost/api/hello
{"message":"Hello World!"}yoshimasa@instance-1:~$ 

---


次にブラウザでも確認する
gce > 外部IP > ブラウザを起動　> http://<external-IP>/api/hello

# 以下が表示される
{"message":"Hello World!"}

---

リバースプロキシの設定はここまで

---


### 4 フロントエンド（JS）とバックエンド（Sinatra）の疎通



cd /var/www/html
yoshimasa@instance-1:/var/www/html$ pwd
/var/www/html
yoshimasa@instance-1:/var/www/html$ ll
total 12
drwxr-xr-x 2 root root 4096 Feb 18 10:00 ./
drwxr-xr-x 3 root root 4096 Feb 17 23:57 ../
-rw-r--r-- 1 root root  883 Feb 18 10:00 index.html

---
cat index.html

このhtmlファイルにJavaScriptを読み込ませる処理を記載していく
---
<!DOCTYOE html>
<html>
    <head>
        <meta charset="utf-8">
        <title>タスク管理アプリケーション</title>
    </head>
    <body>
        <h1>タスク管理アプリケーション</h1>
        <input type="text" />
        <button>追加</button>
        <h2>タスク一覧</h2>
        <table>
            <thead>
                <tr>
                    <th>タイトル</th>
                    <th>作成日時</th>
                </tr>
            </thead>
            <tbody>
                <tr>
                    <td>フロントエンドの実装</td>
                    <td>2023-02-18 00:00:00 +0000</td>
                </tr>
                <tr>
                    <td>サーバーサイドの実装</td>
                    <td>2023-02-18 00:00:00 +0000</td>
                </tr>
            </tbody>

        </table>
        <script src = "main.js"></script>
    </body>
</html>
---

同じディレクトリに「main.js」を作成
sudo vim main.js

console.log 'Hello, JavaScript';


このコードは、HTMLドキュメント内にJavaScriptコードを埋め込む方法の一つです。

<script>タグは、HTMLドキュメント内にJavaScriptコードを記述するために使用されます。source属性は、JavaScriptコードが保存されているファイルのパスを指定します。

例えば、main.jsという名前のJavaScriptファイルが、HTMLファイルと同じディレクトリにある場合、上記のコードを使用してHTMLドキュメント内にJavaScriptコードを挿入できます。

---

ブラウザ　＞　F12 ＞ console で　Hello, JavaScriptと表示されたことを確認

続いてJavaScriptの実装
sudo vim main.js

async function main(){
        console.log ('Hello, JavaScript')
}       

main()
---

再度画面をリロード
「Hello, JavaScript」が表示されることを確認

---

次にmain関数の中でサーバと通信する処理を書く


インデックスを書く

---
<!DOCTYPE html>
<html lang="ja">
  <head>
    <meta charset="utf-8" />
    <title>タスク管理アプリケーション</title>
  </head>
  <body>
    <h1>タスク管理アプリケーション</h1>
    <input type="text" />
    <button>追加</button>
    <h2>タスク一覧</h2>
    <table>
      <thead>
        <tr>
          <th>タイトル</th>
          <th>作成日時</th>
        </tr>
      </thead>
      <tbody>
        <tr>
          <td>フロントエンドの実装</td>
          <td>2022-06-17 01:23:45</td>
        </tr>
        <tr>
          <td>バックエンドの実装</td>
          <td>2022-06-17 01:23:45</td>
        </tr>
      </tbody>
    </table>
    <p id="message"></p>
    <script src="main.js"></script>
  </body>
</html>
---



---

再度JavaScriptの実装

---

async function main() {
  const response = await fetch('/api/hello')
  console.log(response)
  const responseBody = await response.json()
  console.log(responseBody)

  const messageElement = document.getElementById('message')
  messageElement.innerText = responseBody.message
}

main()

---
※sinatraを起動しておかないとエラーする

上記二つのファイルを格納
ブラウザでHelloと表示されることを確認

---
フロントエンドとバックエンドの疎通はこれで完了



## 5 タスク一覧の取得処理を実装

gdc ファイルアップロード

index.html
/var/www/html
sudo mv index_(1).html /var/www/html/index.html


main.js
myapp.rb
/home/yoshimasa/myapp/

sudo mv main.js /home/yoshimasa/myapp/


## 6 タスクの登録処理を実装
gdc ファイルアップロード

index.html
/var/www/html
sudo mv index.html /var/www/html/index.html


main.js
myapp.rb
/home/yoshimasa/myapp/

sudo mv main.js /home/yoshimasa/myapp/



## 

## 

## 

## 










